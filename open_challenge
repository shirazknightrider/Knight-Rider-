import cv2
import numpy as np
import serial
from picamera2 import Picamera2
import time
from gpiozero import Button

# Constants
MIN_BLACK_AREA = 100
FINAL_LAP_COUNT = 3

# Serial setup (assumes Arduino is connected)
ser = serial.Serial('/dev/ttyUSB0', 9600)

# Send command to Arduino
def send_command_to_arduino(command):
    try:
        ser.write((str(command) + "\n").encode('utf-8'))
    except serial.SerialException as e:
        print(f"Error sending data: {e}")

# Detect black contours and draw bounding boxes
def detect_black_contours(subimage):
    lower_black = np.array([0, 0, 0], np.uint8)
    upper_black = np.array([180, 255, 50], np.uint8)
    mask = cv2.inRange(subimage, lower_black, upper_black)
    contours = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
    
    max_area = 0
    x, y = -1, -1
    for contour in contours:
        area = cv2.contourArea(contour)
        if area > max_area:
            max_area = area
            x, y, w, h = cv2.boundingRect(contour)
    
    if max_area > MIN_BLACK_AREA:
        cv2.rectangle(subimage, (x, y), (x + w, y + h), (255, 255, 255), 2)
        return max_area, x, y
    return 0, -1, -1

# Navigation logic
def navigate_robot(black_wall_area_left, black_wall_area_right, black_wall_area_top, lap_count):
    if lap_count >= FINAL_LAP_COUNT:
        print("Final lap completed. Stopping robot.")
        send_command_to_arduino(1500)  # Stop the robot
        return lap_count

    if black_wall_area_top == 0:
        # Increment lap count if no walls are detected
        if black_wall_area_left == 0 and black_wall_area_right == 0:
            lap_count += 1
            print(f"Lap {lap_count} completed.")
            send_command_to_arduino(2100)  # Move forward
        elif black_wall_area_left > 0 and black_wall_area_right == 0:
            print("Left wall detected. Turning right.")
            send_command_to_arduino(2110)  # Turn right
        elif black_wall_area_left == 0 and black_wall_area_right > 0:
            print("Right wall detected. Turning left.")
            send_command_to_arduino(2120)  # Turn left
        elif black_wall_area_left > 0 and black_wall_area_right > 0:
            print("Walls detected on both sides. Moving forward carefully.")
            send_command_to_arduino(2130)  # Move forward carefully
    else:
        # Wall detected on the top
        if black_wall_area_left == 0 and black_wall_area_right == 0:
            print("Wall detected on top, no side walls. Reversing.")
            send_command_to_arduino(2170)  # Move backward
        elif black_wall_area_left > 0 and black_wall_area_right == 0:
            print("Top and left wall detected. Reversing and turning right.")
            send_command_to_arduino(2180)  # Reverse and turn right
        elif black_wall_area_left == 0 and black_wall_area_right > 0:
            print("Top and right wall detected. Reversing and turning left.")
            send_command_to_arduino(2190)  # Reverse and turn left
        elif black_wall_area_left > 0 and black_wall_area_right > 0:
            print("Top and both side walls detected. Stopping.")
            send_command_to_arduino(2200)  # Stop
    
    return lap_count

# Main function
button = Button(17)

def main():
    # Setup for Raspberry Pi Camera Module 3 Wide
    picam2_1 = Picamera2()
    config_1 = picam2_1.create_still_configuration({'size': (640, 480), 'format': 'RGB888', 'buffer_count': 4})
    picam2_1.configure(config_1)
    picam2_1.set_controls({'ExposureTime': 10000, 'AnalogueGain': 1.0})
    picam2_1.start()
    time.sleep(1)

    picam2_2 = Picamera2()
    config_2 = picam2_2.create_still_configuration({'size': (640, 480), 'format': 'RGB888', 'buffer_count': 4})
    picam2_2.configure(config_2)
    picam2_2.set_controls({'ExposureTime': 10000, 'AnalogueGain': 1.0})
    picam2_2.start()
    time.sleep(1)

    lap_count = 0

    while True:
        # Capture frame from both cameras
        full_frame_cam1 = picam2_1.capture_array()

        full_frame_cam2 = picam2_2.capture_array()

        # Define subimage coordinates
        LEFT_SIDE_X_END = 150
        TOP_Y_END = 100
        RIGHT_SIDE_X_START = 490

        # Define subimages for detecting black walls
        black_subimage_left_cam1 = full_frame_cam1[:, :LEFT_SIDE_X_END]
        black_subimage_top_cam1 = full_frame_cam1[:TOP_Y_END, :]
        black_subimage_right_cam2 = full_frame_cam2[:, RIGHT_SIDE_X_START:]
        black_subimage_top_cam2 = full_frame_cam2[:TOP_Y_END, :]

        # Process subimages from both cameras
        black_wall_area_left, _, _ = detect_black_contours(black_subimage_left_cam1)
        black_wall_area_top_cam1, _, _ = detect_black_contours(black_subimage_top_cam1)
        black_wall_area_right, _, _ = detect_black_contours(black_subimage_right_cam2)
        black_wall_area_top_cam2, _, _ = detect_black_contours(black_subimage_top_cam2)

        # Combine results from both cameras
        black_wall_area_top = max(black_wall_area_top_cam1, black_wall_area_top_cam2)

        # Navigate based on detections
        lap_count = navigate_robot(black_wall_area_left, black_wall_area_right, black_wall_area_top, lap_count)

        # Display the frames from both cameras
        cv2.line(full_frame_cam1, (LEFT_SIDE_X_END, 0), (LEFT_SIDE_X_END, full_frame_cam1.shape[0]), (0, 0, 255), 2)
        cv2.line(full_frame_cam1, (0, TOP_Y_END), (full_frame_cam1.shape[1], TOP_Y_END), (0, 0, 255), 2)
        cv2.line(full_frame_cam2, (RIGHT_SIDE_X_START, 0), (RIGHT_SIDE_X_START, full_frame_cam2.shape[0]), (0, 0, 255), 2)
        cv2.line(full_frame_cam2, (0, TOP_Y_END), (full_frame_cam2.shape[1], TOP_Y_END), (0, 0, 255), 2)
        
        cv2.imshow("Camera 1 Frame", full_frame_cam1)
        cv2.imshow("Camera 2 Frame", full_frame_cam2)
        if cv2.waitKey(1) == ord('q'):
            send_command_to_arduino(1500)  # Stop car
            break

        

    cv2.destroyAllWindows()

if __name__ == "__main__":
    print("Waiting for button press to start the program...")
    button.wait_for_press()
    print("Button pressed. Starting the program...")
    main()
